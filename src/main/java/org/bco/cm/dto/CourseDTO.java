/*
 * The MIT License
 *
 * Copyright 2017 Pivotal Software, Inc..
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package org.bco.cm.dto;

import com.fasterxml.jackson.annotation.JsonIgnore;
import java.io.Serializable;
import java.time.Instant;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.MapKey;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import javax.persistence.Transient;
import org.hibernate.annotations.NaturalId;

/**
 * DTO for Course.
 * @author Andr&#233; Juffer, Triacle Biocomputing
 */
@Entity( name = "CourseDTO" )
@Table( name = "courses" )
public class CourseDTO extends AbstractCourseDTO implements Serializable 
{
    private UUID id_;
    private String courseId_;
    private String courseDescriptionId_;
    private Instant startDate_;
    private Instant endDate_;
    private int numberOfSeats_;
    private boolean ongoing_;
    private Map<String, StudentMonitorDTO> roster_;
    
    public CourseDTO()
    {
        super();
        id_ = null;
        courseId_ = null;
        courseDescriptionId_ = null;
        ongoing_ = false;
        startDate_ = Instant.now();
        endDate_ = Instant.now();
        numberOfSeats_ = 0;
        roster_ = new HashMap<>();
    }
    
    private void setId(UUID id)
    {
        id_ = id;
    }
    
    /**
     * Returns identifier generated by repository.
     * @return Identifier.
     */
    @Id
    @GeneratedValue
    protected UUID getId()
    {
        return id_;
    }
    
    public void setCourseId(String courseId)
    {
        courseId_ = courseId;
    }
    
    @Column( name = "course_id" )
    @NaturalId
    public String getCourseId()
    {
        return courseId_;
    }
    
    public void setCourseDescriptionId(String courseDescriptionId)
    {
        courseDescriptionId_ = courseDescriptionId;
    }
    
    @Column( name = "course_description_id" )
    public String getCourseDescriptionId()
    {
        return courseDescriptionId_;
    }
    
    public void setOngoing(boolean ongoing)
    {
        ongoing_ = ongoing;
    }
    
    @Column( name = "ongoing" )
    public boolean getOngoing()
    {
        return ongoing_;
    }
    
    public void setStartDate(Instant startDate)
    {
        startDate_ = startDate;
    }
    
    @Transient
    public Instant getStartDate()
    {
        return startDate_;
    }
    
    public void setStartDateTimestamp(Long timestamp)
    {
        startDate_ = Instant.ofEpochMilli(timestamp);
    }
    
    @Column ( name = "start_date" )
    public Long getStartDateTimestamp()
    {
        return startDate_.toEpochMilli();
    }
    
    public void setEndDate(Instant endDate)
    {
        endDate_ = endDate;
    }
    
    @Transient
    public Instant getEndDate()
    {
        return endDate_;
    }
    
    public void setEndDateTimestamp(Long timestamp)
    {
        endDate_ = Instant.ofEpochMilli(timestamp);
    }
    
    @Column( name = "end_date" )
    public Long getEndDateTimestamp()
    {
        return endDate_.toEpochMilli();
    }
    
    public void setNumberOfSeats(int numberOfSeats)
    {
        numberOfSeats_ = numberOfSeats;
    }
    
    @Column ( name = "number_of_seats" )
    public int getNumberOfSeats()
    {
        return numberOfSeats_;
    }
    
    public void setRoster(Map<String, StudentMonitorDTO> roster)
    {
        roster_ = roster;
    }
    
    @JsonIgnore
    @OneToMany( 
        cascade = CascadeType.ALL, 
        orphanRemoval = true,
        fetch = FetchType.EAGER
    )
    @JoinTable(
        name = "rosters",
        joinColumns = @JoinColumn(name = "course_id"),
        inverseJoinColumns = @JoinColumn(name = "monitor_id")
    )
    @MapKey( name = "studentId" )
    public Map<String,StudentMonitorDTO> getRoster()
    {
        return roster_;
    }
    
    @Transient
    public Collection<StudentMonitorDTO> getStudentMonitors()
    {   
        return roster_.values();
    }
    
    public void setStudentMonitors(Collection<StudentMonitorDTO> monitors)
    {
        roster_.clear();
        monitors.forEach(monitor -> {
            String studentId = monitor.getStudentId();
            roster_.put(studentId, monitor);
        });
    }
    
    @OneToMany(
        mappedBy = "course",
        cascade = CascadeType.ALL, 
        orphanRemoval = true
    )
    public List<ModuleDTO> getModules()
    {
        return super.modules();
    }

    @Override
    public void setParent(ModuleDTO module)
    {
        module.setCourse(this);
    }
    
    @Override
    public String toString()
    {
        String newline = System.getProperty("line.separator");
        StringBuilder s = new StringBuilder("CourseDTO : {").append(newline);
        s.append(super.toString()).append(newline);
        s.append("courseId - ").append(courseId_).append(newline);
        s.append("ongoing - ").append(ongoing_).append(newline);
        s.append("endDate - ").append(endDate_).append(newline);
        s.append("startDate - ").append(startDate_).append(newline);
        s.append("numberOfSeats - ").append(numberOfSeats_).append(newline);
        s.append("roster - ").append(roster_).append(newline);
        s.append("}");
        return s.toString();
    }
    
    @Override
    public boolean equals(Object other)
    {
        if ( this == other ) {
            return true;
        }
        if ( other == null ) {
            return false;
        }
        if ( !(other instanceof CourseDTO) ) {
            return false;
        }
        CourseDTO course = (CourseDTO)other;
        return this.getCourseId().equals(course.getCourseId());
    }

    @Override
    public int hashCode() {
        int hash = 5;
        hash = 37 * hash + Objects.hashCode(this.startDate_);
        hash = 37 * hash + Objects.hashCode(this.endDate_);
        hash = 37 * hash + this.numberOfSeats_;
        hash = 37 * hash + (this.ongoing_ ? 1 : 0);
        hash = 37 * hash + Objects.hashCode(this.roster_);
        return hash;
    }

}
