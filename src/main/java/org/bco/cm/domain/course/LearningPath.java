/*
 * The MIT License
 *
 * Copyright 2017 André H. Juffer, Biocenter Oulu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package org.bco.cm.domain.course;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.UUID;
import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.Table;
import org.bco.cm.dto.LearningPathDTO;
import org.bco.cm.dto.OnlineMaterialDTO;

/**
 * A route, taken by the student through a range of (commonly) e-learning 
 * activities, which allows the student to build knowledge progressively.
 * @author André H. Juffer, Biocenter Oulu
 */
@Entity( name = "LearningPath" )
@Table( name = "learning_paths" )
public class LearningPath {
    
    // For generating online material identifiers that are unique to a given 
    // learning path.
    private final static Random RANDOM;
    
    static {
        RANDOM = new Random();
        RANDOM.setSeed(Instant.now().toEpochMilli());
    }
    
    private UUID id_;    
    private List<OnlineMaterial> materials_;
    
    private Module module_;
    
    LearningPath()
    {
        id_ = null;
        materials_ = new ArrayList<>();
        module_ = null;
    }
    
    private void setId(UUID id)
    {
        id_ = id;
    }
    
    /**
     * Returns identifier as generated by repository.
     * @return Identifier value.
     */
    @Id
    @GeneratedValue
    protected UUID getId()
    {
        return id_;
    }
        
    private void setOnlineMaterials(List<OnlineMaterial> materials)
    {
        if ( materials != null ) {
            materials_ = materials;
            materials_.forEach(material -> {
                material.setLearningPath(this);
            });
        }
    }
    
    /**
     * Returns online materials associated with this learning path.
     * @return Online material. Maybe empty.
     */
    @OneToMany(
        mappedBy = "learningPath",
        cascade = CascadeType.ALL, 
        orphanRemoval = true 
    )
    List<OnlineMaterial> getOnlineMaterials()
    {
        return materials_;
    }
    
    void setModule(Module module)
    {
        module_ = module;
    }
    
    @OneToOne()
    @JoinColumn( name = "module_id" )
    protected Module getModule()
    {
        return module_;
    }
    
    /**
     * Returns new but empty learning path.
     * @return New learning path.
     */
    static LearningPath empty()
    {
        return new LearningPath();
    }
    
    /**
     * Returns new learning path according to specification.
     * @param spec Learning path specification.
     * @return New learning path. May be empty still, if spec did not include
     * online materials.
     */
    static LearningPath valueOf(LearningPathDTO spec)
    {
        if ( spec == null ) {
            throw new NullPointerException("Missing learning path specification.");
        }
        if ( spec.getOnlineMaterials().isEmpty() ) {
            throw new IllegalArgumentException("Empty learning path.");
        }
        LearningPath learningPath = LearningPath.empty();
        spec.getOnlineMaterials().forEach((dto) -> {
            learningPath.appendOnlineMaterial(dto);
        });
        return learningPath;
    }
    
    /**
     * Appends new online material.
     * @param spec New online material.
     */
    void appendOnlineMaterial(OnlineMaterialDTO spec)
    {
        int materialId = this.generateMaterialId();
        OnlineMaterial material = OnlineMaterial.valueOf(materialId, spec);
        material.setLearningPath(this);
        materials_.add(material);
    }
    
    /**
     * Adds online material at the given position. The shifts already existing
     * online material to the right.
     * @param spec New online material.
     * @param position Position.
     */
    void addOnlineMaterial(OnlineMaterialDTO spec, int position)
    {
        int materialId = this.generateMaterialId();
        OnlineMaterial material = OnlineMaterial.valueOf(materialId, spec);
        material.setLearningPath(this);
        materials_.add(position, material);
    }
    
    /**
     * Any online material added to this learning path.
     * @return Result.
     */
    boolean hasOnlineMaterial()
    {
        return materials_.isEmpty();
    }

    /**
     * Returns a data transfer object.
     * @return DTO.
     */
    LearningPathDTO toDTO()
    {
        LearningPathDTO dto = new LearningPathDTO();
        List<OnlineMaterialDTO> omdtos = new ArrayList<>();
        materials_.forEach((material) -> {
            omdtos.add(material.toDTO());
        });
        dto.setOnlineMaterials(omdtos);
        return dto;
    }
    
    /**
     * Returns identifier only unique in context of this learning path.
     * @return Identifier. Always > 0
     */
    private int generateMaterialId()
    {
        int bound = Integer.MAX_VALUE - 1;
        int id = RANDOM.nextInt(bound);
        while ( this.containsMaterialId(id) && id == 0) {
            id = RANDOM.nextInt(bound);
        }
        return id;
    }
    
    private boolean containsMaterialId(int materialId)
    {
        for (OnlineMaterial material : materials_) {
            if ( material.getMaterialId() == materialId ) {
                return true;
            }
        }
        return false;
    }
    
}
