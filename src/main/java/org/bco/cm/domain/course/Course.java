/*
 * The MIT License
 *
 * Copyright 2017 André H. Juffer, Biocenter Oulu.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package org.bco.cm.domain.course;

import com.tribc.cqrs.util.EventUtil;
import com.tribc.ddd.domain.event.Event;
import com.tribc.ddd.domain.event.Eventful;
import java.io.Serializable;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Embedded;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.MapKey;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import javax.persistence.Transient;
import org.bco.cm.domain.course.event.CourseStarted;
import org.bco.cm.domain.student.Student;
import org.bco.cm.domain.student.StudentId;
import org.bco.cm.dto.CourseDTO;
import org.bco.cm.dto.ModuleDTO;
import org.bco.cm.util.Identifiable;
import org.hibernate.annotations.NaturalId;

/**
 * An unit of teaching that typically lasts one academic term. A course is  
 * "active" during a start and an end date. During these times, students can 
 * enroll in the course as long as there are still seats available. 
 * An active course is created from a course description and cannot be modified.
 * During the active period, the teacher starts the course at a time of his 
 * choosing, after which enrolled students can begin with the first module. Students 
 * progress to the next module possibly conditioned on intermediate results 
 * obtained for assignments and/or quizzes.
 * @author André H. Juffer, Biocenter Oulu
 */
@Entity( name = "Course" )
@Table( name = "courses" )
public class Course 
    extends AbstractCourse
    implements Eventful, Identifiable, Serializable {
    
    private UUID id_;
    private CourseId courseId_;
    private CourseDescriptionId courseDescriptionId_;
    private Instant startDate_;
    private Instant endDate_;
    private int numberOfSeats_;
    private boolean ongoing_;
    private Map<StudentId,StudentMonitor> roster_;
    
    private final Collection<Event> events_;
    
    protected Course()
    {
        id_ = null;
        courseId_ = null;
        courseDescriptionId_ = null;
        roster_ = new HashMap<>();  // No student registered.
        startDate_ = Instant.now();
        endDate_ = Instant.now();
        numberOfSeats_ = 0;
        ongoing_ = false;
        events_ = new HashSet<>();
    }
    
    private void setId(UUID id)
    {
        id_ = id;
    }
    
    /**
     * Returns identifier generated by repository.
     * @return Identifier.
     */
    @Id
    @GeneratedValue
    protected UUID getId()
    {
        return id_;
    }
    
    private void setIdentifier(CourseId courseId)
    {
        this.setCourseId(courseId);
    }
    
    /**
     * Returns course identifier.
     * @return Identifier. Never null.
     */
    @Transient
    public CourseId getIdentifier()
    {
        return this.getCourseId();
    }
    
    @Override
    @Transient
    public String getIdentifierAsString() 
    {
        return this.getIdentifier().stringValue();
    }
    
    /**
     * Sets course identifier.
     * @param courseId Identifier. Must not be null.
     */
    protected void setCourseId(CourseId courseId)
    {
        if ( courseId == null ) {
            throw new NullPointerException("Missing course identifier.");
        }
        courseId_ = courseId;
    }
    
    /**
     * Returns course identifier.
     * @return Course identifier. Never null.
     */
    @NaturalId
    @Embedded
    public CourseId getCourseId()
    {
        return courseId_;
    }

    private void setCourseDescriptionId(CourseDescriptionId id)
    {
        if ( id == null ) {
            throw new NullPointerException("Missing course identifier.");
        }
        courseDescriptionId_ = id;
    }
    
    /**
     * Returns course description identifier. This identifier refers to the 
     * course description this course is created from/for.
     * @return Identifier. Never null.
     */
    @Embedded
    public CourseDescriptionId getCourseDescriptionId()
    {
        return courseDescriptionId_;
    }
        
     /**
     * Returns modules.
     * @return Modules. May be empty.
     */
    @OneToMany( 
        mappedBy = "course", 
        cascade = CascadeType.ALL, 
        orphanRemoval = true
    )
    protected List<Module> getModules()
    {
        return super.modules();
    }
    
    @Override
    protected void setParent(Module module)
    {
        module.setCourse(this);
    }
    
    private void setStartDate(Instant startDate)
    {
        if ( startDate == null ) {
            throw new NullPointerException("Course: Missing start date.");
        }
        startDate_ = startDate;
    }
    
    /**
     * Returns date after which this course is active.
     * @return Date. Never null.
     */
    @Transient
    public Instant getStartDate()
    {
        return startDate_;
    }
    
    private void setStartDateTimestamp(Long timestamp)
    {
        startDate_ = Instant.ofEpochMilli(timestamp);
    }
    
    @Column ( name = "start_date" )
    protected Long getStartDateTimestamp()
    {
        return startDate_.toEpochMilli();
    }
    
    private void setEndDate(Instant endDate)
    {
        if ( endDate == null ) {
            throw new NullPointerException("Course: Missing end date.");
        }
        endDate_ = endDate;
    }
    
    /**
     * Returns date after which this course is not anymore active.
     * @return End date.
     */
    @Transient
    public Instant getEndDate()
    {
        return endDate_;
    }
    
    private void setEndDateTimestamp(Long timestamp)
    {
        endDate_ = Instant.ofEpochMilli(timestamp);
    }
    
    @Column( name = "end_date" )
    protected Long getEndDateTimestamp()
    {
        return endDate_.toEpochMilli();
    }
    
    private void setNumberOfSeats(int numberOfSeats)
    {
        if ( numberOfSeats <= 0 ) {
            throw new IllegalArgumentException(
                "Course: number of seats must be a positive integer."
            );
        }
        numberOfSeats_ = numberOfSeats;
    }
    
    /**
     * Returns number of available seats.
     * @return Number, always > 0.
     */
    @Column( name = "number_of_seats " )
    public int getNumberOfSeats()
    {
        return numberOfSeats_;
    }
    
    private void setRoster(Map<StudentId, StudentMonitor> roster)
    {
        if ( roster_ == null ) {
            throw new NullPointerException("Missing student roster.");
        }
        roster_ = roster;
    }
    
    /**
     * Returns students.
     * @return Students. May be empty.
     */
    @OneToMany( cascade = CascadeType.ALL, orphanRemoval = true )
    @JoinTable(
        name = "rosters",
        joinColumns = @JoinColumn(name = "course_id"),
        inverseJoinColumns = @JoinColumn(name = "monitor_id")
    )
    @MapKey( name = "studentId" )
    protected Map<StudentId, StudentMonitor> getRoster()
    {
        return roster_;
    }
    
    /**
     * Returns student monitors.
     * @return Roster. Never null. May be empty.
     */
    public List<StudentMonitor> roster()
    {
        return Collections.unmodifiableList(new ArrayList<>(roster_.values()));
    }
    
    private void setOngoing(boolean ongoing)
    {
        ongoing_ = ongoing;
    }
    
    @Column( name = "ongoing" )
    protected boolean getOngoing()
    {
        return ongoing_;
    }
    
    /**
     * Activates a course. 
     * @param courseId New course identifier.
     * @param courseDescription Course description the activated course is based on. 
     * Must hold modules.
     * @param spec New course specification. Must include start date and end date, and
     * the number of available seats.
     * @return New course. This is a full copy of the original course description, such
     * that changes to the course description will not alter the activated course. It
     * shared the same courseId as the course description.
     */
    public static Course activate(CourseId courseId,
                                  CourseDescription courseDescription,
                                  CourseDTO spec)
    {
        // Validate.
        if ( !courseDescription.hasModules() ) {
            throw new IllegalArgumentException(
                "Course must provide at least one module to be activated."
            );
        }        
        Course course = new Course();
        
        // Make a copy of the course description.
        course.setCourseId(courseId);
        course.setCourseDescriptionId(courseDescription.getCourseDescriptionId());
        course.setTitle(courseDescription.getTitle());
        course.setSummary(courseDescription.getSummary());
        for (Module original : courseDescription.getModules() ) {
            ModuleDTO copy = original.toDTO();
            course.addModule(copy);            
        }
        course.setTeacherId(courseDescription.getTeacherId());
        
        // Specification.
        course.setStartDate(spec.getStartDate());
        course.setEndDate(spec.getEndDate());
        course.setNumberOfSeats(spec.getNumberOfSeats());
        
        // Done.
        return course;
    }
    
    /**
     * Notification of course enrolment. If the course is 
     * ongoing, the student gains access to the first module.
     * @param student Student.
     * @throws IllegalStateException if registration is not yet open, student 
     * is already enrolled in course, or no more seats are available in the course.
     */
    public void enrolled(Student student)
    {
        if ( !this.isActive() ) {
            throw new IllegalStateException("Registration is not yet open.");
        }
        if ( this.isEnrolled(student) ) {
            throw new IllegalStateException("Student already enrolled in course.");
        }
        if ( !this.hasSeatsAvailable() ) {
            throw new IllegalStateException("No more seats available in course.");
        }
        int monitorId = this.generateMonitorId();
        StudentMonitor monitor = new StudentMonitor(monitorId, student);        
        roster_.put(student.getStudentId(), monitor);
        
        // Give access to first module if the course is already ongoing.
        if ( this.isOngoing() ) {
            Module first = this.firstModule();
            monitor.toFirstModule(first);
        }        
    }
    
    /**
     * Notification of canceling of enrolment.
     * @param student Student.
     */
    public void enrolmentCanceled(Student student)
    {
        roster_.remove(student.getStudentId());
    }
    
    /**
     * Start this course. Enrolled students gain access to the first module. 
     * Raises an CourseStarted event.
     * @see org.bco.cm.domain.course.event.CourseStarted
     */
    void start()
    {
        if ( !this.isActive() ) {
            throw new IllegalStateException("Course is not active.");
        }
        ongoing_ = true;
        this.started();
        this.giveStudentsAccessToFirstModule();
    }
    
    /**
     * Ends this course. This means that all activities undertaken by students 
     * enrolled in this course are halted.
     * @see #isOngoing()
     */
    public void end()
    {
        ongoing_ = false;
    }
    
    /**
     * Is this course currently ongoing?
     * @return Result. False if this course is not active, otherwise true if teacher
     * started this course.
     * @see #start()
     * @see #end()
     * @see #isActive() 
     */
    @Transient
    public boolean isOngoing()
    {
        if ( this.isActive() ) {
            return ongoing_ == true;
        } else {
            return false;
        }
    }
    
    /**
     * Is this course already active?
     * @return True if the current time is after the start date but before the end date,
     * other false.
     */
    @Transient
    public boolean isActive()
    {
        Instant now = Instant.now();
        return ( now.isAfter(startDate_) && now.isBefore(endDate_) );
    }
    
    /**
     * Course has already ended?
     * @return Result.
     */
    public boolean hasEnded()
    {
        if ( this.isOngoing() ) {
            return false;
        }
        Instant now = Instant.now();
        return now.isAfter((endDate_));
    }
        
    /**
     * Notification of module completion. Student is allowed to transfer to 
     * the next module.
     * @param student Student.
     * @throws IllegalStateException if this course is not ongoing.
     */
    public void moduleCompleted(Student student)
    {
        if ( !this.isOngoing() ) {
            throw new IllegalStateException("Course is currently not ongoing.");
        }
        StudentMonitor monitor = roster_.get(student.getStudentId());
        
        //monitor.toNextModule();
    }
    
    /**
     * Returns a data transfer object.
     * @return DTO.
     */
    public CourseDTO toDTO()
    {
        CourseDTO dto = new CourseDTO();
        this.populate(dto);
        dto.setCourseId(courseId_.stringValue());
        dto.setCourseDescriptionId(courseDescriptionId_.stringValue());
        dto.setRoster(StudentMonitor.toDTOs(roster_.values()));
        dto.setOngoing(ongoing_);
        dto.setStartDate(startDate_);
        dto.setEndDate(endDate_);
        dto.setNumberOfSeats(numberOfSeats_);
        return dto;
    }
    
    /**
     * Are there still seats available?
     * @return Result.
     */
    public boolean hasSeatsAvailable()
    {
        return roster_.size() < numberOfSeats_;
    }
    
    private Module firstModule()
    {
        return this.getModules().get(0);
    }
    
    private void giveStudentsAccessToFirstModule()
    {
        Module first = this.firstModule();
        roster_.values().forEach((monitor) -> {
            monitor.toFirstModule(first);
        });
    }
    
    @Override
    @Transient
    public Collection<Event> getEvents() 
    {
        return EventUtil.selectUnhandled(events_);
    }

    @Override
    public void clearEvents() 
    {
        events_.clear();
    }
    
    @Override
    public boolean equals(Object other)
    {
        if ( this == other ) {
            return true;
        }
        if ( other == null ) {
            return false;
        }
        if ( !(other instanceof Course) ) {
            return false;
        }
        Course course = (Course)other;
        return this.getCourseId().equals(course.getCourseId());
    }

    @Override
    public int hashCode() {
        int hash = 3;
        hash = 29 * hash + Objects.hashCode(this.startDate_);
        hash = 29 * hash + Objects.hashCode(this.endDate_);
        hash = 29 * hash + this.numberOfSeats_;
        hash = 29 * hash + (this.ongoing_ ? 1 : 0);
        hash = 29 * hash + Objects.hashCode(this.roster_);
        return hash;
    }
    
    private void started()
    {
        events_.add(new CourseStarted(this));
    }
    
    private boolean isEnrolled(Student student)
    {
        return roster_.containsKey(student.getStudentId());
    }
    
    private boolean containsStudentMonitor(int monitorId)
    {
        for (StudentMonitor monitor: this.roster() ) {
            if ( monitor.getMonitorId() == monitorId ) {
                return true;
            }
        }
        return false;
    }
    
    private int generateMonitorId()
    {
        int bound = Integer.MAX_VALUE - 100;
        int id = RANDOM.nextInt(bound);
        while (this.containsStudentMonitor(id) && id == 0) {
            id = RANDOM.nextInt(bound);
        }
        return id;
    }

}
